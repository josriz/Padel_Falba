import React, { useState, useEffect, useCallback } from "react";
import { supabase } from "../supabaseClient";Â 

// ðŸ›‘ Import CSS rimosso per stabilitÃ : import "./TournamentDashboard.css"; ðŸ›‘

// Il componente ora utilizza stili in linea (inline styles) per il layout di base.
export default function TournamentDashboard({ isAdmin }) {
Â  Â  const [players, setPlayers] = useState([]);
Â  Â  const [matches, setMatches] = useState([]);
Â  Â  const [loading, setLoading] = useState(true);
Â  Â  const [form, setForm] = useState({ name: "", surname: "", email: "", phone: "" });
Â  Â  const [message, setMessage] = useState("");

Â  Â  // --- UTILITY: Mappa i dati del DB in round per la visualizzazione ---
Â  Â  const organizeMatchesByRound = useCallback((allMatches) => {
Â  Â  Â  Â  const rounds = {};
Â  Â  Â  Â  allMatches.forEach(match => {
Â  Â  Â  Â  Â  Â  const roundName = `round${match.round_number}`; 
Â  Â  Â  Â  Â  Â  if (!rounds[roundName]) {
Â  Â  Â  Â  Â  Â  Â  Â  rounds[roundName] = [];
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  rounds[roundName].push(match);
Â  Â  Â  Â  });
Â  Â  Â  Â  Object.keys(rounds).forEach(key => {
Â  Â  Â  Â  Â  Â  rounds[key].sort((a, b) => (a.match_index || 0) - (b.match_index || 0));
Â  Â  Â  Â  });
Â  Â  Â  Â  return rounds;
Â  Â  }, []);

Â  Â  // --- LOGICA FETCHING DATI ---
Â  Â  useEffect(() => {
Â  Â  Â  Â  fetchData();
Â  Â  }, []);

Â  Â  const fetchData = async () => {
Â  Â  Â  Â  setLoading(true);
Â  Â  Â  Â  setMessage("");
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  // 1. Carica tutti i giocatori
Â  Â  Â  Â  Â  Â  const { data: pData, error: pError } = await supabase
Â  Â  Â  Â  Â  Â  Â  Â  .from("tournament_players")
Â  Â  Â  Â  Â  Â  Â  Â  .select("id, name, surname");
Â  Â  Â  Â  Â  Â  if (pError) throw pError;
Â  Â  Â  Â  Â  Â  setPlayers(pData);

Â  Â  Â  Â  Â  Â  // 2. Carica tutti i match del tabellone
Â  Â  Â  Â  Â  Â  const { data: mData, error: mError } = await supabase
Â  Â  Â  Â  Â  Â  Â  Â  .from("tournament_matches")
Â  Â  Â  Â  Â  Â  Â  Â  .select("*")
Â  Â  Â  Â  Â  Â  Â  Â  .order("round_number", { ascending: false })
Â  Â  Â  Â  Â  Â  Â  Â  .order("match_index", { ascending: true });
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  if (mError) throw mError;
Â  Â  Â  Â  Â  Â  setMatches(mData || []);

Â  Â  Â  Â  } catch (e) {
Â  Â  Â  Â  Â  Â  console.error("Errore fetchData:", e.message);
Â  Â  Â  Â  Â  Â  setMessage("Errore caricamento dati: " + e.message);
Â  Â  Â  Â  }
Â  Â  Â  Â  setLoading(false);
Â  Â  };


Â  Â  // --- LOGICA ISCRIZIONE GIOCATORE (CREATE) ---
Â  Â  const handleRegister = async (e) => {
Â  Â  Â  Â  e.preventDefault();
Â  Â  Â  Â  if (!form.name || !form.surname || !form.email || !form.phone) {
Â  Â  Â  Â  Â  Â  setMessage("Compila tutti i campi");
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }
Â  Â  Â  Â  if (players.length >= 32) {
Â  Â  Â  Â  Â  Â  setMessage("Iscrizioni chiuse, posti terminati!");
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  const { error } = await supabase.from("tournament_players").insert([form]);
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (!error) {
Â  Â  Â  Â  Â  Â  setForm({ name: "", surname: "", email: "", phone: "" });
Â  Â  Â  Â  Â  Â  fetchData(); 
Â  Â  Â  Â  Â  Â  setMessage("âœ… Iscrizione avvenuta!");
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  setMessage("âŒ Errore iscrizione: " + error.message);
Â  Â  Â  Â  }
Â  Â  };


Â  Â  // --- LOGICA AVANZAMENTO VINCITORE (PERSISTENTE) ---
Â  Â  const advanceWinner = async (currentMatch, winnerId) => {
Â  Â  Â  Â  if (!winnerId) return;

Â  Â  Â  Â  const nextRound = currentMatch.round_number / 2; 
Â  Â  Â  Â  const targetIndex = Math.floor(currentMatch.match_index / 2);
Â  Â  Â  Â  const fieldToUpdate = currentMatch.match_index % 2 === 0 ? "player_a_id" : "player_b_id";

Â  Â  Â  Â  const nextMatch = matches.find(
Â  Â  Â  Â  Â  Â  m => m.round_number === nextRound && m.match_index === targetIndex
Â  Â  Â  Â  );

Â  Â  Â  Â  if (!nextMatch) {
Â  Â  Â  Â  Â  Â  const { error: insertError } = await supabase.from("tournament_matches").insert({
Â  Â  Â  Â  Â  Â  Â  Â  round_number: nextRound,
Â  Â  Â  Â  Â  Â  Â  Â  match_index: targetIndex,
Â  Â  Â  Â  Â  Â  Â  Â  [fieldToUpdate]: winnerId,
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  if (insertError) console.error("Errore creazione match successivo:", insertError.message);

Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  const { error: updateError } = await supabase.from("tournament_matches")
Â  Â  Â  Â  Â  Â  Â  Â  .update({ [fieldToUpdate]: winnerId })
Â  Â  Â  Â  Â  Â  Â  Â  .eq("id", nextMatch.id);
Â  Â  Â  Â  Â  Â  if (updateError) console.error("Errore aggiornamento match successivo:", updateError.message);
Â  Â  Â  Â  }
Â  Â  };


Â  Â  // --- LOGICA AGGIORNAMENTO PUNTEGGI (PERSISTENTE) ---
Â  Â  const updateMatchScore = async (matchId, roundNumber, matchIndex, playerAId, playerBId, scoreA, scoreB, side, score) => {
Â  Â  Â  Â  if (!isAdmin) {
Â  Â  Â  Â  Â  Â  Â setMessage("Non hai i permessi per aggiornare il punteggio.");
Â  Â  Â  Â  Â  Â  Â return;
Â  Â  Â  Â  }

Â  Â  Â  Â  const parsedScore = score === "" ? null : parseInt(score, 10);
Â  Â  Â  Â  let currentScoreA = side === "a" ? parsedScore : scoreA;
Â  Â  Â  Â  let currentScoreB = side === "b" ? parsedScore : scoreB;

Â  Â  Â  Â  const updatePayload = {
Â  Â  Â  Â  Â  Â  score_a: currentScoreA,
Â  Â  Â  Â  Â  Â  score_b: currentScoreB,
Â  Â  Â  Â  Â  Â  winner_id: null,
Â  Â  Â  Â  };

Â  Â  Â  Â  let winnerId = null;

Â  Â  Â  Â  if (currentScoreA !== null && currentScoreB !== null) {
Â  Â  Â  Â  Â  Â  if (currentScoreA > currentScoreB) {
Â  Â  Â  Â  Â  Â  Â  Â  winnerId = playerAId;
Â  Â  Â  Â  Â  Â  } else if (currentScoreB > currentScoreA) {
Â  Â  Â  Â  Â  Â  Â  Â  winnerId = playerBId;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  updatePayload.winner_id = winnerId;
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  const { error } = await supabase.from("tournament_matches")
Â  Â  Â  Â  Â  Â  .update(updatePayload)
Â  Â  Â  Â  Â  Â  .eq("id", matchId);

Â  Â  Â  Â  if (error) {
Â  Â  Â  Â  Â  Â  console.error("Errore updateMatchScore:", error.message);
Â  Â  Â  Â  Â  Â  setMessage("âŒ Errore nel salvataggio del punteggio.");
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  setMessage("Punteggio aggiornato!");
Â  Â  Â  Â  Â  Â  if (winnerId) {
Â  Â  Â  Â  Â  Â  Â  Â  await advanceWinner({ round_number: roundNumber, match_index: matchIndex }, winnerId);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  fetchData();Â 
Â  Â  Â  Â  }
Â  Â  };


Â  Â  // --- COMPONENTE MATCH PER LA VISUALIZZAZIONE ---
Â  Â  const Match = ({ match }) => {
Â  Â  Â  Â  const playerA = players.find(p => p.id === match.player_a_id);
Â  Â  Â  Â  const playerB = players.find(p => p.id === match.player_b_id);

Â  Â  Â  Â  return (
Â  Â  Â  Â  Â  Â  <div style={{ border: '1px solid #ddd', padding: '10px', marginBottom: '10px', display: 'flex', gap: '5px', alignItems: 'center', backgroundColor: match.winner_id ? '#e6ffe6' : '#fff', borderRadius: '4px' }}>
Â  Â  Â  Â  Â  Â  Â  Â  <span style={{ width: '150px' }}>{playerA ? `${playerA.name} ${playerA.surname}` : "Giocatore A"}</span>
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  {/* Visualizzazione/Input Punteggio A */}
Â  Â  Â  Â  Â  Â  Â  Â  <input
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  type="number"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  min="0"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  style={{ width: '60px', textAlign: 'center', padding: '5px' }}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  placeholder="A"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  value={match.score_a ?? ""}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onChange={e => updateMatchScore(match.id, match.round_number, match.match_index, match.player_a_id, match.player_b_id, match.score_a, match.score_b, "a", e.target.value)}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  disabled={!isAdmin || !playerA}
Â  Â  Â  Â  Â  Â  Â  Â  />
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  <span>-</span>

Â  Â  Â  Â  Â  Â  Â  Â  {/* Visualizzazione/Input Punteggio B */}
Â  Â  Â  Â  Â  Â  Â  Â  <input
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  type="number"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  min="0"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  style={{ width: '60px', textAlign: 'center', padding: '5px' }}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  placeholder="B"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  value={match.score_b ?? ""}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onChange={e => updateMatchScore(match.id, match.round_number, match.match_index, match.player_a_id, match.player_b_id, match.score_a, match.score_b, "b", e.target.value)}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  disabled={!isAdmin || !playerB}
Â  Â  Â  Â  Â  Â  Â  Â  />
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  <span style={{ width: '150px' }}>{playerB ? `${playerB.name} ${playerB.surname}` : "Giocatore B"}</span>
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  {match.winner_id && <span style={{ color: 'green', fontWeight: 'bold', marginLeft: '10px' }}>ðŸ† Vincitore: {players.find(p => p.id === match.winner_id)?.name}</span>}
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  );
Â  Â  };
Â  Â Â 
Â  Â  const organizedRounds = organizeMatchesByRound(matches);

Â  Â  if (loading) return <p style={{ padding: '20px' }}>Caricamento torneo...</p>;

Â  Â  return (
Â  Â  Â  Â  <div style={{ padding: '20px', maxWidth: '1200px', margin: '0 auto' }}>
Â  Â  Â  Â  Â  Â  <h1>Torneo Padel</h1>

Â  Â  Â  Â  Â  Â  {!isAdmin && (
Â  Â  Â  Â  Â  Â  Â  Â  <form onSubmit={handleRegister} style={{ display: 'flex', gap: '10px', flexWrap: 'wrap', marginBottom: '30px', padding: '15px', border: '1px solid #ccc', borderRadius: '5px' }}>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <input type="text" placeholder="Nome" value={form.name} onChange={e => setForm({...form, name:e.target.value})} required style={{ padding: '8px', flexGrow: '1' }}/>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <input type="text" placeholder="Cognome" value={form.surname} onChange={e => setForm({...form, surname:e.target.value})} required style={{ padding: '8px', flexGrow: '1' }}/>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <input type="email" placeholder="Email" value={form.email} onChange={e => setForm({...form, email:e.target.value})} required style={{ padding: '8px', flexGrow: '1' }}/>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <input type="text" placeholder="Cellulare" value={form.phone} onChange={e => setForm({...form, phone:e.target.value})} required style={{ padding: '8px', flexGrow: '1' }}/>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button type="submit" style={{ padding: '8px 15px', backgroundColor: '#007bff', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer', flexShrink: '0' }}>Iscriviti</button>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <p style={{ width: '100%', margin: '0', color: message.includes('âœ…') ? 'green' : 'red' }}>{message}</p>
Â  Â  Â  Â  Â  Â  Â  Â  </form>
Â  Â  Â  Â  Â  Â  )}
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  {isAdmin && message && <p style={{ color: 'blue', border: '1px solid lightblue', padding: '10px' }}>{message}</p>}

Â  Â  Â  Â  Â  Â  <h2>Tabellone</h2>
Â  Â  Â  Â  Â  Â  <div style={{ display: 'flex', overflowX: 'auto', paddingBottom: '15px' }}>
Â  Â  Â  Â  Â  Â  Â  Â  {/* Mappa dinamicamente i round disponibili */}
Â  Â  Â  Â  Â  Â  Â  Â  {Object.keys(organizedRounds).map(roundKey => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const roundNumber = organizedRounds[roundKey][0]?.round_number;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!roundNumber) return null;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return (
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div key={roundKey} style={{ marginRight: '30px', minWidth: '350px' }}>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <h3 style={{ borderBottom: '2px solid #ddd', paddingBottom: '5px' }}>{roundNumber === 16 ? "Sedicesimi" : roundNumber === 8 ? "Quarti" : roundNumber === 4 ? "Semifinali" : roundNumber === 2 ? "Finale" : `Round ${roundNumber}`}</h3>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  {organizedRounds[roundKey].map((m) => (
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <Match key={m.id} match={m} />
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ))}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  );
Â  Â  Â  Â  Â  Â  Â  Â  })}

Â  Â  Â  Â  Â  Â  Â  Â  {matches.length === 0 && <p>Nessun match caricato. L'Admin deve inizializzare il primo round nel DB.</p>}
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </div>
Â  Â  );
}